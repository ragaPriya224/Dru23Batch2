DEFINE THREAD?
1. extending thread class
2. implementing runnable interface

t.start() -> heart of multithreading

what happens in start() -> registering the thread with thread scheduler, perform all other mandatory activities required for thread, invoke run();

Thread Scheduler ->part of JVM.
                   responsible to schedule thread i.e., if multiple threads waiting, which order thread executed is decided by thread scheduler.


t.start() -> create separate thread which is responsible for run()

can we overload run method? yes, but t.start calls no-arg run method only. other overloaded method must be called explicitly  like normal method call.

can we override start method? not recommended 
---------------------------------------thread life cycle -----if everything goes fine------------
MyThread t = new MyThread();  new  ___t.start()____> ready/runnable ___if t.s allocates processor ___> running__________if run() method completes__>dead

if t.start() -> call same thread again or restart -> IllegalThreadStateException

which way is better? by implementing runnable interface
y? can extend another class, will be able to inheritance benefits

main thread is responsible for executing main method
every thread has name, set by programmer or jvm
Thread.currentThread().getName();
Thread.currentThread().setName("NAME");

THREAD PRIORITIES:
1 to 10 -> priority
1-> min, 10 -> max, 5 -> normal 
if any other number given, -> ILLEGAL ARGUMENT EXCEPTION 
Either thread has priority -> either generated by JVM
                              customised priority provided by programmer. 

setPriority(int P);
getPriority();

Default priority : main -> 5
                   others -> inherited from parent thread to child thread
                   
--------------------PREVENTING THREAD EXECUTION----------------------

1. YIELD() 
   pause its current execution and give chance for remaining waiting threads of same priority
yield call na -> move from running state to runnable state 

2.JOIN()
  if thread wants to wait, until completion of other thread.
  t1,t2.. so t1 call ts.join();
  it waits until t2 gets completed. 

  running state to wait state to ready state 
waiting state to ready state na -> t2.completed or time expired or waiting thread interrupted

3.SLEEP() 
if a thread doesn't want to perform any operation, for a particular amount of time, 





























